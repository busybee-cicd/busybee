{"version":3,"file":"KeyIdentifier.js","sourceRoot":"","sources":["KeyIdentifier.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\r\n\r\nexport class KeyIdentifier {\r\n  static process(config: any, expected: any, actual: any, action: (key: string, ex: any, ac: any) => void) {\r\n    // parse the config payload\r\n    config.forEach((configItem) => {\r\n      if (_.isObject(configItem) && !_.isArray(configItem)) {\r\n        KeyIdentifier.parseConfigObject(configItem, expected, actual, action);\r\n      } else if (_.isString(configItem)) {\r\n        KeyIdentifier.parseConfigString(configItem, expected, actual, action);\r\n      }\r\n    });\r\n\r\n    return {expected, actual};\r\n  }\r\n\r\n  /*\r\n   Called when the initial process() method encounters an Object\r\n   */\r\n  private static parseConfigObject(configObj, expected, actual, action: (key: string, expected: any, actual: any) => void) {\r\n    _.forEach(configObj, (v, k) => {\r\n      // first split the key to see if we need to traverse further before performing the supplied action\r\n      let keyArray = k === '*' ? [k] : k.split('.');\r\n      if (keyArray.length > 1) {\r\n        // we need to dive deeper..this key describes further nesting ie) key.childKey.grandChild.key\r\n        KeyIdentifier.parseConfigObjectPathString(k, v, expected, actual, action);\r\n        return;\r\n      }\r\n\r\n      if (_.isArray(v)) {\r\n        v.forEach((keyToRemove) => {\r\n          // keyToRemove could be a string or an object\r\n          if (_.isObject(keyToRemove) && !_.isArray(keyToRemove)) { // an object describing further recursion\r\n            // advance the expected/actual and pass in the keyToRemove (configObj)\r\n            let nextExpected = expected[k];\r\n            let nextActual = actual[k];\r\n            if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) { // if this next key is a collection in our actual/expected\r\n              nextExpected.forEach((_nextExpected, i) => {\r\n                KeyIdentifier.parseConfigObject(keyToRemove, _nextExpected, nextActual[i], action);\r\n              })\r\n            } else {\r\n              KeyIdentifier.parseConfigObject(keyToRemove, nextExpected, nextActual, action);\r\n            }\r\n\r\n          } else { // simply a string representing a key to remove at this iteration\r\n            KeyIdentifier.advanceAndRemoveKey(k, keyToRemove, expected, actual, action);\r\n          }\r\n        });\r\n      } else if (_.isObject(v)) {\r\n        let nextExpected = expected[k];\r\n        let nextActual = actual[k];\r\n        if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n          nextExpected.forEach((_nextExpected, i) => {\r\n            KeyIdentifier.parseConfigObject(v, _nextExpected, actual[i], action);\r\n          });\r\n        } else {\r\n          KeyIdentifier.parseConfigObject(v, nextExpected, nextActual, action);\r\n        }\r\n      } else if (_.isString(v)) {\r\n        KeyIdentifier.advanceAndRemoveKey(k, v, expected, actual, action);\r\n      }\r\n    });\r\n  }\r\n\r\n  private static advanceAndRemoveKey(advanceKey, keyToRemove, actual, expected, action: (key: string, expected: any, actual: any) => void) {\r\n    let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\r\n    let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\r\n    if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n      nextExpected.forEach((_nextExpected, i) => {\r\n        action(keyToRemove, _nextExpected, nextActual[i]);\r\n      });\r\n    } else {\r\n      action(keyToRemove, nextExpected, nextActual);\r\n    }\r\n  }\r\n\r\n  /*\r\n   Called when the initial process() method encounters a String as\r\n   opposed to an object at the top-level\r\n   */\r\n  private static parseConfigString(configString, expected, actual, action: (key: string, expected: any, actual: any) => void) {\r\n    let configArr = configString === '*' ? [configString] : configString.split('.');\r\n    if (configArr.length === 1) {\r\n      action(configArr[0], expected, actual);\r\n\r\n      return;\r\n    }\r\n\r\n    let advanceKey = configArr.shift();\r\n    let nextConfigString = configArr.join('.');\r\n    let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\r\n    let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\r\n    if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n      nextExpected.forEach((_nextExpected, i) => {\r\n        KeyIdentifier.parseConfigString(nextConfigString, _nextExpected, nextActual[i], action);\r\n      });\r\n    } else {\r\n      KeyIdentifier.parseConfigString(nextConfigString, nextExpected, nextActual, action);\r\n    }\r\n  };\r\n\r\n  /*\r\n   Called when a key has been encounted which represents a nested path\r\n   ie) \"my.nested.path\" : \"keyToRemove\" | { \"object\": \"toContinueParsingOnceTraversed\" }\r\n   */\r\n  private static parseConfigObjectPathString(configStringKey, configValue, expected, actual, action: (key: string, expected: any, actual: any) => void) {\r\n    // goal here is to split the string, advance to the next item, once fully advanced, take action\r\n    let configArr = configStringKey === '*' ? [configStringKey] : configStringKey.split('.');\r\n    if (configArr.length > 1) {\r\n      // advance in the expected and actual objects and recurse\r\n      let advanceKey = configArr.shift();\r\n      let nextConfigStringKey = configArr.join(\".\");\r\n      let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\r\n      let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\r\n      if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n        nextExpected.forEach((_nextExpected, i) => {\r\n          KeyIdentifier.parseConfigObjectPathString(nextConfigStringKey, configValue, _nextExpected, nextActual[i], action);\r\n        });\r\n      } else {\r\n        KeyIdentifier.parseConfigObjectPathString(nextConfigStringKey, configValue, nextExpected, nextActual, action);\r\n      }\r\n    } else {\r\n      // take action\r\n      let advanceKey = configArr[0];\r\n      let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\r\n      let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\r\n      // the value could be another object, an array of keys to delete\r\n      if (_.isArray(configValue)) { // always a have to check _.isArray first because _.isObject([]) == true\r\n        // remove all these dang keys\r\n        configValue.forEach((keyToRemove) => {\r\n          if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n            nextExpected.forEach((_nextExpected, i) => {\r\n              action(keyToRemove, _nextExpected, nextActual[i]);\r\n              //KeyIdentifier.deleteKey(keyToRemove, _nextExpected, nextActual[i]);\r\n            })\r\n          } else {\r\n            action(keyToRemove, nextExpected, nextActual);\r\n            //KeyIdentifier.deleteKey(keyToRemove, nextExpected, nextActual);\r\n          }\r\n        });\r\n      } else if (_.isObject(configValue)) {\r\n        // advance in expected/actual and then parse the obj\r\n        if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\r\n          nextExpected.forEach((_nextExpected, i) => {\r\n            KeyIdentifier.parseConfigObject(configValue, _nextExpected, nextActual[i], action);\r\n          })\r\n        } else {\r\n          KeyIdentifier.parseConfigObject(configValue, nextExpected, nextActual, action);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static deleteKey(key, expected, actual) {\r\n    delete expected[key];\r\n    delete actual[key];\r\n  }\r\n\r\n  private static valueIsArray(expected, actual) {\r\n    return _.isArray(expected) && _.isArray(actual);\r\n  }\r\n}\r\n"]}