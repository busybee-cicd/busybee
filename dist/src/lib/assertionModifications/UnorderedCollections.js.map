{"version":3,"file":"UnorderedCollections.js","sourceRoot":"","sources":["../../../../src/lib/assertionModifications/UnorderedCollections.ts"],"names":[],"mappings":"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","sourcesContent":["import {KeyIdentifier} from \"./KeyIdentifier\";\nimport * as _ from 'lodash';\n\nexport class UnorderedCollections {\n\n    static process(config: any, expected: any, actual: any) {\n        try {\n            KeyIdentifier.process(config, expected, actual, (currentKey, _expected, _actual) => {\n                // compare the 2 collections\n                let expectedCol;\n                let actualCol;\n                if (_expected[currentKey]) {\n                    expectedCol = _expected[currentKey];\n                    actualCol = _actual[currentKey];\n                } else if (currentKey == '*' || _.isArray(_expected)) {\n                    expectedCol = _expected;\n                    actualCol = _actual;\n                }\n\n                if (!expectedCol && !actualCol) {\n                    throw new Error(`The collection at '${currentKey}' cannot be found. It's possible that this collection is nested under an unorderedCollection that has already been asserted or that the collection simply does not exist.`);\n                }\n\n                // check length.\n                if (expectedCol.length != actualCol.length) {\n                    throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expectedCol.length}, Actual == ${expectedCol.length}`)\n                }\n\n                UnorderedCollections.testEqualityOfCollections(expectedCol, actualCol, currentKey);\n            });\n        } catch (e) {\n            throw e;\n           // throw new Error(`Error encountered while applying your 'assertionModifications.unorderedCollection'. Please confirm 'assertionModifications.unorderedCollection' is formatted correctly`)\n        }\n    }\n\n    static testEqualityOfCollections(expected: any, actual: any, currentKey: string) {\n        if (expected.length != actual.length) {\n            throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expected.length}, Actual == ${actual.length}`)\n        }\n\n        let expectedOrdered = [];\n        let actualOrdered = [];\n        expected.forEach((expectedItem) => {\n            let result = _.find(actual, (actualItem) => {\n                ////////\n                // We don't support {'hello': [[1],[2,3],[4]]}\n                ///////\n                if (_.isArray(actualItem)) {\n                   throw new Error(`Sorry, assertionModifications.unorderedCollection doesn't support collections directly nested in collections at this. ie) {'hello': [[1],[2,3],[4]]}`);\n                };\n\n                // 1. make copy. if what we're comparing is an array of arrays we just set to null because we're not going to support this;\n                let expectedItemWithCollsRemoved = _.isObject(expectedItem) ? Object.assign({}, expectedItem) : expectedItem;\n                let actualItemWithCollsRemoved = _.isObject(actualItem) ? Object.assign({}, actualItem) : actualItem;\n\n                // 2. remove any child collections\n                if (_.isObject(expectedItemWithCollsRemoved)) {\n                    if (UnorderedCollections.hasChildCollections(expectedItemWithCollsRemoved)\n                        || UnorderedCollections.hasChildCollections(actualItemWithCollsRemoved)) {\n                        UnorderedCollections.deleteCollectionsFromObj(expectedItemWithCollsRemoved);\n                        UnorderedCollections.deleteCollectionsFromObj(actualItemWithCollsRemoved);\n                    }\n                }\n\n                // 3. test that our items, minus any collections, are equal\n                let itemsAreEqual = _.isEqual(expectedItemWithCollsRemoved, actualItemWithCollsRemoved);\n\n                if (itemsAreEqual) {\n                    expectedOrdered.push(expectedItem);\n                    actualOrdered.push(actualItem);\n                }\n\n                return itemsAreEqual;\n            });\n\n            if (!result) {\n                throw new Error(`The collections at '${currentKey}' are not equal`);\n            }\n        });\n\n\n        actual.splice(0, actual.length, ...actualOrdered);\n        expected.splice(0, expected.length, ...expectedOrdered);\n    }\n\n    static hasChildCollections(obj: any) {\n        let ret = false;\n\n        _.forEach(obj, (v, k) => {\n            if (_.isArray(v)) {\n                ret = true;\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    static deleteCollectionsFromObj(obj) {\n        _.forEach(obj, (v, k) => {\n            if (_.isArray(v)) {\n                delete obj[k];\n            }\n        })\n    }\n\n}"]}