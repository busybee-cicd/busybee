{"version":3,"file":"UnorderedCollections.js","sourceRoot":"","sources":["../../../../src/lib/assertionModifications/UnorderedCollections.ts"],"names":[],"mappings":"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","sourcesContent":["import {KeyIdentifier} from \"./KeyIdentifier\";\r\nimport * as _ from 'lodash';\r\nimport { Logger } from 'busybee-util';\r\n\r\n/*\r\n Will only check that the collections specified are equal. Any child collections are ignored during the equality check.\r\n However, the collections tested ARE ordered as a result of the testing and therefor any child collections can be\r\n tested for equality further down the road.\r\n ie) if the config is ['*', '*.collection'] then the first iteration is dealing with '*'\r\n EXPECTED\r\n [\r\n {\r\n id: 1,\r\n collection: [a,b,c]\r\n },\r\n {\r\n id: 2,\r\n collection [d,e,f]\r\n }\r\n ]\r\n\r\n ACTUAL\r\n [\r\n {\r\n id: 2,\r\n collection [f,e,d]\r\n },\r\n {\r\n id: 1,\r\n collection: [c,b,a]\r\n },\r\n\r\n ]\r\n\r\n becomes\r\n\r\n EXPECTED\r\n [\r\n {\r\n id: 1,\r\n collection: [a,b,c]\r\n },\r\n {\r\n id: 2,\r\n collection [d,e,f]\r\n }\r\n ]\r\n\r\n ACTUAL\r\n [\r\n {\r\n id: 1,\r\n collection: [c,b,a]\r\n },\r\n {\r\n id: 2,\r\n collection [f,e,d]\r\n }\r\n ]\r\n\r\n Now that the outter-most collection has been deemed equal (not including child collections) and re-ordered\r\n so that EXEPECTED and ACTUAL are in the same order. On the next iteration when we're dealing with '*.collection'\r\n the 'collection' key enters the iteration with the 'collections' matched\r\n\r\n EXPECTED\r\n collection: [a,b,c]\r\n\r\n ACTUAL\r\n collection: [c,b,a]\r\n\r\n Next iteration\r\n\r\n EXPECTED\r\n collection [d,e,f]\r\n ACTUAL\r\n collection [f,e,d]\r\n\r\n */\r\nexport class UnorderedCollections {\r\n\r\n  static process(config: any, expected: any, actual: any, logger:Logger = null) {\r\n    KeyIdentifier.process(config, expected, actual, (currentKey, _expected, _actual) => {\r\n      // compare the 2 collections\r\n      let expectedCol;\r\n      let actualCol;\r\n\r\n      if (_expected[currentKey]) {\r\n        expectedCol = _expected[currentKey];\r\n        actualCol = _actual[currentKey];\r\n      } else if (currentKey == '*' || (_.isArray(_expected) && _.isArray(_actual))) {\r\n        expectedCol = _expected;\r\n        actualCol = _actual;\r\n      }\r\n\r\n      if (!expectedCol && !actualCol) {\r\n        // if we can't find the key then we assume that it may be null OR omitted\r\n        // this can happen if they reference something deeply nested that isn't required. don't throw an error, just bail\r\n        return;\r\n      }\r\n\r\n      // check length.\r\n      if (expectedCol.length != actualCol.length) {\r\n        throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expectedCol.length}, Actual == ${expectedCol.length}`)\r\n      }\r\n\r\n      UnorderedCollections.testEqualityOfCollections(expectedCol, actualCol, currentKey);\r\n    });\r\n  }\r\n\r\n  static testEqualityOfCollections(expected: any, actual: any, currentKey: string) {\r\n    if (expected.length != actual.length) {\r\n      throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expected.length}, Actual == ${actual.length}`)\r\n    }\r\n\r\n    let expectedOrdered = [];\r\n    let actualOrdered = [];\r\n    expected.forEach((expectedItem) => {\r\n      let result = _.find(actual, (actualItem) => {\r\n        ////////\r\n        // We don't support {'hello': [[1],[2,3],[4]]}\r\n        ///////\r\n        if (_.isArray(actualItem)) {\r\n          throw new Error(`Sorry, assertionModifications.unorderedCollection doesn't support collections directly nested in collections at this. ie) {'hello': [[1],[2,3],[4]]}`);\r\n        }\r\n        ;\r\n\r\n        // 1. make copy. if what we're comparing is an array of arrays we just set to null because we're not going to support this;\r\n        let expectedItemWithCollsRemoved = _.isObject(expectedItem) ? Object.assign({}, expectedItem) : expectedItem;\r\n        let actualItemWithCollsRemoved = _.isObject(actualItem) ? Object.assign({}, actualItem) : actualItem;\r\n\r\n        // 2. remove any child collections (we wont take these into account for equality check)\r\n        if (_.isObject(expectedItemWithCollsRemoved)) {\r\n          if (UnorderedCollections.hasChildCollections(expectedItemWithCollsRemoved)\r\n            || UnorderedCollections.hasChildCollections(actualItemWithCollsRemoved)) {\r\n            UnorderedCollections.deleteCollectionsFromObj(expectedItemWithCollsRemoved);\r\n            UnorderedCollections.deleteCollectionsFromObj(actualItemWithCollsRemoved);\r\n          }\r\n        }\r\n\r\n        // 3. test that our items, minus any collections, are equal\r\n        let itemsAreEqual = _.isEqual(expectedItemWithCollsRemoved, actualItemWithCollsRemoved);\r\n\r\n        if (itemsAreEqual) {\r\n          expectedOrdered.push(expectedItem);\r\n          actualOrdered.push(actualItem);\r\n        }\r\n\r\n        return itemsAreEqual;\r\n      });\r\n\r\n      if (!result) {\r\n        throw new Error(`The collections at '${currentKey}' are not equal OR the parent object is a member of an ambiguous collection`);\r\n      }\r\n    });\r\n\r\n\r\n    actual.splice(0, actual.length, ...actualOrdered);\r\n    expected.splice(0, expected.length, ...expectedOrdered);\r\n  }\r\n\r\n  static hasChildCollections(obj: any) {\r\n    let ret = false;\r\n\r\n    _.forEach(obj, (v, k) => {\r\n      if (_.isArray(v)) {\r\n        ret = true;\r\n        return false;\r\n      }\r\n    });\r\n\r\n    return ret;\r\n  }\r\n\r\n  static deleteCollectionsFromObj(obj) {\r\n    _.forEach(obj, (v, k) => {\r\n      if (_.isArray(v)) {\r\n        delete obj[k];\r\n      }\r\n    })\r\n  }\r\n\r\n}\r\n"]}