{"version":3,"file":"UnorderedCollections.js","sourceRoot":"","sources":["../../../../src/lib/assertionModifications/UnorderedCollections.ts"],"names":[],"mappings":";;AAAA,iDAA8C;AAC9C,0BAA4B;AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyEG;AACH;IAAA;IAmGA,CAAC;IAjGU,4BAAO,GAAd,UAAe,MAAW,EAAE,QAAa,EAAE,MAAW;QAClD,6BAAa,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAC,UAAU,EAAE,SAAS,EAAE,OAAO;YAC3E,4BAA4B;YAC5B,IAAI,WAAW,CAAC;YAChB,IAAI,SAAS,CAAC;YACd,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBACxB,WAAW,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;gBACpC,SAAS,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;YACpC,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,IAAI,GAAG,IAAI,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACnD,WAAW,GAAG,SAAS,CAAC;gBACxB,SAAS,GAAG,OAAO,CAAC;YACxB,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBAC7B,MAAM,IAAI,KAAK,CAAC,wBAAsB,UAAU,8KAA2K,CAAC,CAAC;YACjO,CAAC;YAED,gBAAgB;YAChB,EAAE,CAAC,CAAC,WAAW,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;gBACzC,MAAM,IAAI,KAAK,CAAC,yBAAuB,UAAU,+CAA0C,WAAW,CAAC,MAAM,oBAAe,WAAW,CAAC,MAAQ,CAAC,CAAA;YACrJ,CAAC;YAED,oBAAoB,CAAC,yBAAyB,CAAC,WAAW,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;QACvF,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,8CAAyB,GAAhC,UAAiC,QAAa,EAAE,MAAW,EAAE,UAAkB;QAC3E,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,yBAAuB,UAAU,+CAA0C,QAAQ,CAAC,MAAM,oBAAe,MAAM,CAAC,MAAQ,CAAC,CAAA;QAC7I,CAAC;QAED,IAAI,eAAe,GAAG,EAAE,CAAC;QACzB,IAAI,aAAa,GAAG,EAAE,CAAC;QACvB,QAAQ,CAAC,OAAO,CAAC,UAAC,YAAY;YAC1B,IAAI,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,UAAC,UAAU;gBACnC,QAAQ;gBACR,8CAA8C;gBAC9C,OAAO;gBACP,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACzB,MAAM,IAAI,KAAK,CAAC,sJAAsJ,CAAC,CAAC;gBAC3K,CAAC;gBAAA,CAAC;gBAEF,2HAA2H;gBAC3H,IAAI,4BAA4B,GAAG,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,YAAY,CAAC,GAAG,YAAY,CAAC;gBAC7G,IAAI,0BAA0B,GAAG,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,UAAU,CAAC,GAAG,UAAU,CAAC;gBAErG,uFAAuF;gBACvF,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,4BAA4B,CAAC,CAAC,CAAC,CAAC;oBAC3C,EAAE,CAAC,CAAC,oBAAoB,CAAC,mBAAmB,CAAC,4BAA4B,CAAC;2BACnE,oBAAoB,CAAC,mBAAmB,CAAC,0BAA0B,CAAC,CAAC,CAAC,CAAC;wBAC1E,oBAAoB,CAAC,wBAAwB,CAAC,4BAA4B,CAAC,CAAC;wBAC5E,oBAAoB,CAAC,wBAAwB,CAAC,0BAA0B,CAAC,CAAC;oBAC9E,CAAC;gBACL,CAAC;gBAED,2DAA2D;gBAC3D,IAAI,aAAa,GAAG,CAAC,CAAC,OAAO,CAAC,4BAA4B,EAAE,0BAA0B,CAAC,CAAC;gBAExF,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;oBAChB,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;oBACnC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACnC,CAAC;gBAED,MAAM,CAAC,aAAa,CAAC;YACzB,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,yBAAuB,UAAU,oBAAiB,CAAC,CAAC;YACxE,CAAC;QACL,CAAC,CAAC,CAAC;QAGH,MAAM,CAAC,MAAM,OAAb,MAAM,GAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,SAAK,aAAa,GAAE;QAClD,QAAQ,CAAC,MAAM,OAAf,QAAQ,GAAQ,CAAC,EAAE,QAAQ,CAAC,MAAM,SAAK,eAAe,GAAE;IAC5D,CAAC;IAEM,wCAAmB,GAA1B,UAA2B,GAAQ;QAC/B,IAAI,GAAG,GAAG,KAAK,CAAC;QAEhB,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,UAAC,CAAC,EAAE,CAAC;YAChB,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACf,GAAG,GAAG,IAAI,CAAC;gBACX,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAEM,6CAAwB,GAA/B,UAAgC,GAAG;QAC/B,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,UAAC,CAAC,EAAE,CAAC;YAChB,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACf,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAEL,2BAAC;AAAD,CAAC,AAnGD,IAmGC;AAnGY,oDAAoB","sourcesContent":["import {KeyIdentifier} from \"./KeyIdentifier\";\nimport * as _ from 'lodash';\n\n/*\n    Will only check that the collections specified are equal. Any child collections are ignored during the equality check.\n    However, the collections tested ARE ordered as a result of the testing and therefor any child collections can be\n    tested for equality further down the road.\n    ie) if the config is ['*', '*.collection'] then the first iteration is dealing with '*'\n    EXPECTED\n    [\n        {\n          id: 1,\n          collection: [a,b,c]\n        },\n        {\n          id: 2,\n          collection [d,e,f]\n        }\n    ]\n\n    ACTUAL\n    [\n         {\n             id: 2,\n             collection [f,e,d]\n         },\n        {\n            id: 1,\n            collection: [c,b,a]\n        },\n\n    ]\n\n    becomes\n\n     EXPECTED\n     [\n         {\n             id: 1,\n             collection: [a,b,c]\n         },\n         {\n             id: 2,\n             collection [d,e,f]\n         }\n     ]\n\n     ACTUAL\n     [\n         {\n             id: 1,\n             collection: [c,b,a]\n         },\n             {\n             id: 2,\n             collection [f,e,d]\n         }\n     ]\n\n    Now that the outter-most collection has been deemed equal (not including child collections) and re-ordered\n    so that EXEPECTED and ACTUAL are in the same order. On the next iteration when we're dealing with '*.collection'\n    the 'collection' key enters the iteration with the 'collections' matched\n\n    EXPECTED\n        collection: [a,b,c]\n\n    ACTUAL\n        collection: [c,b,a]\n\n    Next iteration\n\n    EXPECTED\n        collection [d,e,f]\n    ACTUAL\n        collection [f,e,d]\n\n */\nexport class UnorderedCollections {\n\n    static process(config: any, expected: any, actual: any) {\n        KeyIdentifier.process(config, expected, actual, (currentKey, _expected, _actual) => {\n            // compare the 2 collections\n            let expectedCol;\n            let actualCol;\n            if (_expected[currentKey]) {\n                expectedCol = _expected[currentKey];\n                actualCol = _actual[currentKey];\n            } else if (currentKey == '*' || _.isArray(_expected)) {\n                expectedCol = _expected;\n                actualCol = _actual;\n            }\n\n            if (!expectedCol && !actualCol) {\n                throw new Error(`The collection at '${currentKey}' cannot be found. It's possible that this collection is nested under an unorderedCollection that has already been asserted or that the collection simply does not exist.`);\n            }\n\n            // check length.\n            if (expectedCol.length != actualCol.length) {\n                throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expectedCol.length}, Actual == ${expectedCol.length}`)\n            }\n\n            UnorderedCollections.testEqualityOfCollections(expectedCol, actualCol, currentKey);\n        });\n    }\n\n    static testEqualityOfCollections(expected: any, actual: any, currentKey: string) {\n        if (expected.length != actual.length) {\n            throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expected.length}, Actual == ${actual.length}`)\n        }\n\n        let expectedOrdered = [];\n        let actualOrdered = [];\n        expected.forEach((expectedItem) => {\n            let result = _.find(actual, (actualItem) => {\n                ////////\n                // We don't support {'hello': [[1],[2,3],[4]]}\n                ///////\n                if (_.isArray(actualItem)) {\n                   throw new Error(`Sorry, assertionModifications.unorderedCollection doesn't support collections directly nested in collections at this. ie) {'hello': [[1],[2,3],[4]]}`);\n                };\n\n                // 1. make copy. if what we're comparing is an array of arrays we just set to null because we're not going to support this;\n                let expectedItemWithCollsRemoved = _.isObject(expectedItem) ? Object.assign({}, expectedItem) : expectedItem;\n                let actualItemWithCollsRemoved = _.isObject(actualItem) ? Object.assign({}, actualItem) : actualItem;\n\n                // 2. remove any child collections (we wont take these into account for equality check)\n                if (_.isObject(expectedItemWithCollsRemoved)) {\n                    if (UnorderedCollections.hasChildCollections(expectedItemWithCollsRemoved)\n                        || UnorderedCollections.hasChildCollections(actualItemWithCollsRemoved)) {\n                        UnorderedCollections.deleteCollectionsFromObj(expectedItemWithCollsRemoved);\n                        UnorderedCollections.deleteCollectionsFromObj(actualItemWithCollsRemoved);\n                    }\n                }\n\n                // 3. test that our items, minus any collections, are equal\n                let itemsAreEqual = _.isEqual(expectedItemWithCollsRemoved, actualItemWithCollsRemoved);\n\n                if (itemsAreEqual) {\n                    expectedOrdered.push(expectedItem);\n                    actualOrdered.push(actualItem);\n                }\n\n                return itemsAreEqual;\n            });\n\n            if (!result) {\n                throw new Error(`The collections at '${currentKey}' are not equal`);\n            }\n        });\n\n\n        actual.splice(0, actual.length, ...actualOrdered);\n        expected.splice(0, expected.length, ...expectedOrdered);\n    }\n\n    static hasChildCollections(obj: any) {\n        let ret = false;\n\n        _.forEach(obj, (v, k) => {\n            if (_.isArray(v)) {\n                ret = true;\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    static deleteCollectionsFromObj(obj) {\n        _.forEach(obj, (v, k) => {\n            if (_.isArray(v)) {\n                delete obj[k];\n            }\n        })\n    }\n\n}"]}