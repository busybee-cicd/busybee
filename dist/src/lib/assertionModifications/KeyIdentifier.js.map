{"version":3,"file":"KeyIdentifier.js","sourceRoot":"","sources":["../../../../src/lib/assertionModifications/KeyIdentifier.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\n\nexport class KeyIdentifier {\n    static process(config: any, expected: any, actual: any, action: (key:string, ex:any, ac:any) => void) {\n        // parse the config payload\n        config.forEach((configItem) => {\n            if (_.isObject(configItem) && !_.isArray(configItem)) {\n                KeyIdentifier.parseConfigObject(configItem, expected, actual, action);\n            } else if (_.isString(configItem)) {\n                KeyIdentifier.parseConfigString(configItem, expected, actual, action);\n            }\n        });\n\n        return {expected, actual};\n    }\n\n    /*\n        Called when the initial process() method encounters an Object\n     */\n    private static parseConfigObject(configObj, expected, actual, action: (key:string, expected:any, actual:any) => void) {\n        _.forEach(configObj, (v, k) => {\n            // first split the key to see if we need to traverse further before performing the supplied action\n            let keyArray = k === '*' ? [k] : k.split('.');\n            if (keyArray.length > 1) {\n                // we need to dive deeper..this key describes further nesting ie) key.childKey.grandChild.key\n                KeyIdentifier.parseConfigObjectPathString(k, v, expected, actual, action);\n                return;\n            }\n\n            if (_.isArray(v)) {\n                v.forEach((keyToRemove) => {\n                    // keyToRemove could be a string or an object\n                    if (_.isObject(keyToRemove) && !_.isArray(keyToRemove)) { // an object describing further recursion\n                        // advance the expected/actual and pass in the keyToRemove (configObj)\n                        let nextExpected = expected[k];\n                        let nextActual = actual[k];\n                        if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) { // if this next key is a collection in our actual/expected\n                            nextExpected.forEach((_nextExpected, i) => {\n                                KeyIdentifier.parseConfigObject(keyToRemove, _nextExpected, nextActual[i], action);\n                            })\n                        } else {\n                            KeyIdentifier.parseConfigObject(keyToRemove, nextExpected, nextActual, action);\n                        }\n\n                    } else { // simply a string representing a key to remove at this iteration\n                        KeyIdentifier.advanceAndRemoveKey(k, keyToRemove, expected, actual, action);\n                    }\n                });\n            } else if (_.isObject(v)) {\n                let nextExpected = expected[k];\n                let nextActual = actual[k];\n                if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n                    nextExpected.forEach((_nextExpected, i) => {\n                        KeyIdentifier.parseConfigObject(v, _nextExpected, actual[i], action);\n                    });\n                } else {\n                    KeyIdentifier.parseConfigObject(v, nextExpected, nextActual, action);\n                }\n            } else if (_.isString(v)) {\n                KeyIdentifier.advanceAndRemoveKey(k, v, expected, actual, action);\n            }\n        });\n    }\n\n    private static advanceAndRemoveKey(advanceKey, keyToRemove, actual, expected, action: (key:string, expected:any, actual:any) => void) {\n        let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\n        let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\n        if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n            nextExpected.forEach((_nextExpected, i) => {\n                action(keyToRemove, _nextExpected, nextActual[i]);\n            });\n        } else {\n            action(keyToRemove, nextExpected, nextActual);\n        }\n    }\n\n    /*\n        Called when the initial process() method encounters a String as\n        opposed to an object at the top-level\n     */\n    private static parseConfigString(configString, expected, actual, action: (key:string, expected:any, actual:any) => void) {\n        let configArr = configString === '*' ? [configString] : configString.split('.');\n        if (configArr.length === 1) {\n            if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n                nextExpected.for((_nextExpected, i) => {\n                    action(configArr[0], _nextExpected, actual[i]);\n                })\n            } else {\n                action(configArr[0], expected, actual);\n            }\n\n            return;\n        }\n\n        let advanceKey = configArr.shift();\n        let nextConfigString = configArr.join('.');\n        let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\n        let nextActual = advanceKey === '*'? actual : actual[advanceKey];\n        if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n            nextExpected.forEach((_nextExpected, i) => {\n                KeyIdentifier.parseConfigString(nextConfigString, _nextExpected, nextActual[i], action);\n            });\n        } else {\n            KeyIdentifier.parseConfigString(nextConfigString, nextExpected, nextActual, action);\n        }\n    };\n\n    /*\n     Called when a key has been encounted which represents a nested path\n     ie) \"my.nested.path\" : \"keyToRemove\" | { \"object\": \"toContinueParsingOnceTraversed\" }\n     */\n    private static parseConfigObjectPathString(configStringKey, configValue, expected, actual, action: (key:string, expected:any, actual:any) => void) {\n        // goal here is to split the string, advance to the next item, once fully advanced, take action\n        let configArr = configStringKey === '*' ? [configStringKey] : configStringKey.split('.');\n        if (configArr.length > 1) {\n            // advance in the expected and actual objects and recurse\n            let advanceKey = configArr.shift();\n            let nextConfigStringKey = configArr.join(\".\");\n            let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\n            let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\n            if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n                nextExpected.forEach((_nextExpected, i) => {\n                    KeyIdentifier.parseConfigObjectPathString(nextConfigStringKey, configValue, _nextExpected, nextActual[i], action);\n                });\n            } else {\n                KeyIdentifier.parseConfigObjectPathString(nextConfigStringKey, configValue, nextExpected, nextActual, action);\n            }\n        } else {\n            // take action\n            let advanceKey = configArr[0];\n            let nextExpected = advanceKey === '*' ? expected : expected[advanceKey];\n            let nextActual = advanceKey === '*' ? actual : actual[advanceKey];\n            // the value could be another object, an array of keys to delete\n            if (_.isArray(configValue)) { // always a have to check _.isArray first because _.isObject([]) == true\n                // remove all these dang keys\n                configValue.forEach((keyToRemove) => {\n                    if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n                        nextExpected.forEach((_nextExpected, i) => {\n                            action(keyToRemove, _nextExpected, nextActual[i]);\n                            //KeyIdentifier.deleteKey(keyToRemove, _nextExpected, nextActual[i]);\n                        })\n                    } else {\n                        action(keyToRemove, nextExpected, nextActual);\n                        //KeyIdentifier.deleteKey(keyToRemove, nextExpected, nextActual);\n                    }\n                });\n            } else if (_.isObject(configValue)) {\n                // advance in expected/actual and then parse the obj\n                if (KeyIdentifier.valueIsArray(nextExpected, nextActual)) {\n                    nextExpected.forEach((_nextExpected, i) => {\n                        KeyIdentifier.parseConfigObject(configValue, _nextExpected, nextActual[i], action);\n                    })\n                } else {\n                    KeyIdentifier.parseConfigObject(configValue, nextExpected, nextActual, action);\n                }\n            }\n        }\n    }\n\n    private static deleteKey(key, expected, actual) {\n        delete expected[key];\n        delete actual[key];\n    }\n\n    private static valueIsArray(expected, actual) {\n        return _.isArray(expected) && _.isArray(actual);\n    }\n}"]}