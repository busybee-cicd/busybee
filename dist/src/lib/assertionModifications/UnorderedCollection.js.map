{"version":3,"file":"UnorderedCollection.js","sourceRoot":"","sources":["../../../../src/lib/assertionModifications/UnorderedCollection.ts"],"names":[],"mappings":";;AAAA,iDAA8C;AAC9C,0BAA4B;AAE5B;IAAA;IAiCA,CAAC;IA/BU,2BAAO,GAAd,UAAe,MAAW,EAAE,QAAa,EAAE,MAAW;QAClD,IAAI,CAAC;YACD,6BAAa,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAC,UAAU,EAAE,QAAQ,EAAE,MAAM;gBACzE,4BAA4B;gBAC5B,IAAI,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;gBACvC,IAAI,SAAS,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;gBAEnC,gBAAgB;gBAChB,EAAE,CAAC,CAAC,WAAW,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;oBACzC,MAAM,IAAI,KAAK,CAAC,yBAAuB,UAAU,+CAA0C,WAAW,CAAC,MAAM,oBAAe,WAAW,CAAC,MAAQ,CAAC,CAAA;gBACrJ,CAAC;gBAED,WAAW,CAAC,OAAO,CAAC,UAAC,YAAY;oBAC7B,IAAI,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,UAAC,UAAU;wBACtC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;oBAC/C,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACV,MAAM,IAAI,KAAK,CAAC,yBAAuB,UAAU,oBAAiB,CAAC,CAAC;oBACxE,CAAC;gBACL,CAAC,CAAC,CAAC;gBAEH,oEAAoE;gBACpE,OAAO,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC5B,OAAO,MAAM,CAAC,UAAU,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;QACP,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,MAAM,IAAI,KAAK,CAAC,wKAAwK,CAAC,CAAA;QAC7L,CAAC;IACL,CAAC;IAEL,0BAAC;AAAD,CAAC,AAjCD,IAiCC;AAjCY,kDAAmB","sourcesContent":["import {KeyIdentifier} from \"./KeyIdentifier\";\nimport * as _ from 'lodash';\n\nexport class UnorderedCollection {\n\n    static process(config: any, expected: any, actual: any) {\n        try {\n            KeyIdentifier.process(config, expected, actual, (currentKey, expected, actual) => {\n                // compare the 2 collections\n                let expectedCol = expected[currentKey];\n                let actualCol = actual[currentKey];\n\n                // check length.\n                if (expectedCol.length != actualCol.length) {\n                    throw new Error(`The collections at '${currentKey}' are not of equal length. Expected == ${expectedCol.length}, Actual == ${expectedCol.length}`)\n                }\n\n                expectedCol.forEach((expectedItem) => {\n                    let result = _.find(actualCol, (actualItem) => {\n                        return _.isEqual(expectedItem, actualItem);\n                    });\n\n                    if (!result) {\n                        throw new Error(`The collections at '${currentKey}' are not equal`);\n                    }\n                });\n\n                // remove these collections once they've been confirmed to be equal.\n                delete expected[currentKey];\n                delete actual[currentKey];\n            });\n        } catch (e) {\n            throw new Error(`Error encountered while applying your 'assertionModifications.unorderedCollection'. Please confirm 'assertionModifications.unorderedCollection' is formatted correctly`)\n        }\n    }\n\n}"]}