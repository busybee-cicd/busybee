{"version":3,"file":"IgnoreKeys.js","sourceRoot":"","sources":["../../../src/lib/IgnoreKeys.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\n\nexport class IgnoreKeys {\n    static process(ignore, expected, actual) {\n        // parse the ignore payload\n        ignore.forEach((ignoreItem) => {\n            if (_.isObject(ignoreItem) && !_.isArray(ignoreItem)) {\n                IgnoreKeys.parseIgnoreObject(ignoreItem, expected, actual);\n            } else if (_.isString(ignoreItem)) {\n                IgnoreKeys.parseIgnoreString(ignoreItem, expected, actual);\n            }\n        });\n\n        return {expected, actual};\n    }\n\n    /*\n        Called when the initial process() method encounters an Object\n     */\n    private static parseIgnoreObject(ignoreObj, expected, actual) {\n        _.forEach(ignoreObj, (v, k) => {\n            // first split the key to see if we need to traverse further before deleting anything\n            let keyArray = k.split(\".\");\n            if (keyArray.length > 1) {\n                // we need to dive deeper..this key describes further nesting ie) key.childKey.grandChild.key\n                IgnoreKeys.parseIgnoreObjectPathString(k, v, expected, actual);\n                return;\n            }\n\n            if (_.isArray(v)) {\n                v.forEach((keyToRemove) => {\n                    // keyToRemove could be a string or an object\n                    if (_.isObject(keyToRemove) && !_.isArray(keyToRemove)) { // an object describing further recursion\n                        // advance the expected/actual and pass in the keyToRemove (ignoreObj)\n                        let nextExpected = expected[k];\n                        let nextActual = actual[k];\n                        if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) { // if this next key is a collection in our actual/expected\n                            nextExpected.forEach((_nextExpected, i) => {\n                                IgnoreKeys.parseIgnoreObject(keyToRemove, _nextExpected, nextActual[i]);\n                            })\n                        } else {\n                            IgnoreKeys.parseIgnoreObject(keyToRemove, nextExpected, nextActual);\n                        }\n\n                    } else { // simply a string representing a key to remove at this iteration\n                        IgnoreKeys.advanceAndRemoveKey(k, keyToRemove, expected, actual);\n                    }\n                });\n            } else if (_.isObject(v)) {\n                let nextExpected = expected[k];\n                let nextActual = actual[k];\n                if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n                    nextExpected.forEach((_nextExpected, i) => {\n                        IgnoreKeys.parseIgnoreObject(v, _nextExpected, actual[i]);\n                    });\n                } else {\n                    IgnoreKeys.parseIgnoreObject(v, nextExpected, nextActual);\n                }\n            } else if (_.isString(v)) {\n                IgnoreKeys.advanceAndRemoveKey(k, v, expected, actual);\n            }\n        });\n    }\n\n    private static advanceAndRemoveKey(advanceKey, keyToRemove, actual, expected) {\n        let nextExpected = expected[advanceKey];\n        let nextActual = actual[advanceKey];\n        if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n            nextExpected.forEach((_nextExpected, i) => {\n                IgnoreKeys.deleteKey(keyToRemove, _nextExpected, nextActual[i]);\n            });\n        } else {\n            IgnoreKeys.deleteKey(keyToRemove, nextExpected, nextActual);\n        }\n    }\n\n    /*\n        Called when the initial process() method encounters a String as\n        opposed to an object at the top-level\n     */\n    private static parseIgnoreString(ignoreString, expected, actual) {\n        let ignoreArr = ignoreString.split('.');\n        if (ignoreArr.length === 1) {\n            IgnoreKeys.deleteKey(ignoreArr[0], expected, actual);\n            return;\n        }\n\n        let advanceKey = ignoreArr.shift();\n        let nextIgnoreString = ignoreArr.join('.');\n        let nextExpected = expected[advanceKey];\n        let nextActual = actual[advanceKey];\n        if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n            nextExpected.forEach((_nextExpected, i) => {\n                IgnoreKeys.parseIgnoreString(nextIgnoreString, _nextExpected, nextActual[i]);\n            });\n        } else {\n            IgnoreKeys.parseIgnoreString(nextIgnoreString, nextExpected, nextActual);\n        }\n    };\n\n    /*\n     Called when a key has been encounted which represents a nested path\n     ie) \"my.nested.path\" : \"keyToRemove\" | { \"object\": \"toContinueParsingOnceTraversed\" }\n     */\n    private static parseIgnoreObjectPathString(ignoreStringKey, ignoreValue, expected, actual) {\n        // goal here is to split the string, advance to the next item, once fully advanced, take action\n        let ignoreArr = ignoreStringKey.split(\".\");\n        if (ignoreArr.length > 1) {\n            // advance in the expected and actual objects and recurse\n            let advanceKey = ignoreArr.shift();\n            let nextIgnoreStringKey = ignoreArr.join(\".\");\n            let nextExpected = expected[advanceKey];\n            let nextActual = actual[advanceKey];\n            if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n                nextExpected.forEach((_nextExpected, i) => {\n                    IgnoreKeys.parseIgnoreObjectPathString(nextIgnoreStringKey, ignoreValue, _nextExpected, nextActual[i]);\n                });\n            } else {\n                IgnoreKeys.parseIgnoreObjectPathString(nextIgnoreStringKey, ignoreValue, nextExpected, nextActual);\n            }\n        } else {\n            // take action\n            let advanceKey = ignoreArr[0];\n            let nextExpected = expected[advanceKey];\n            let nextActual = actual[advanceKey];\n            // the value could be another object, an array of keys to delete\n            if (_.isArray(ignoreValue)) { // always a have to check _.isArray first because _.isObject([]) == true\n                // remove all these dang keys\n                ignoreValue.forEach((keyToRemove) => {\n                    if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n                        nextExpected.forEach((_nextExpected, i) => {\n                            IgnoreKeys.deleteKey(keyToRemove, _nextExpected, nextActual[i]);\n                        })\n                    } else {\n                        IgnoreKeys.deleteKey(keyToRemove, nextExpected, nextActual);\n                    }\n                });\n            } else if (_.isObject(ignoreValue)) {\n                // advance in expected/actual and then parse the obj\n                if (IgnoreKeys.valueIsArray(nextExpected, nextActual)) {\n                    nextExpected.forEach((_nextExpected, i) => {\n                        IgnoreKeys.parseIgnoreObject(ignoreValue, _nextExpected, nextActual[i]);\n                    })\n                } else {\n                    IgnoreKeys.parseIgnoreObject(ignoreValue, nextExpected, nextActual);\n                }\n            }\n        }\n    }\n\n    private static deleteKey(key, expected, actual) {\n        delete expected[key];\n        delete actual[key];\n    }\n\n    private static valueIsArray(expected, actual) {\n        return _.isArray(expected) && _.isArray(actual);\n    }\n}"]}