{"version":3,"file":"unorderedCollectionsTest.js","sourceRoot":"","sources":["../../../test/assertionModifications/unorderedCollectionsTest.ts"],"names":[],"mappings":"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","sourcesContent":["import test from 'ava';\r\nimport {UnorderedCollections} from \"../../src/lib/assertionModifications/UnorderedCollections\";\r\n\r\ntest(`'*' will only check the top-level collection and does not apply to any unordered subCollections`, (t) => {\r\n    let expected = [\r\n        {\r\n            subCollection: [\r\n                1,2,3,4\r\n            ]\r\n        },\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                5,6,7,8\r\n            ]\r\n        }\r\n    ];\r\n\r\n    let actual = [\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                8,6,7,5\r\n            ]\r\n        },\r\n        {\r\n            subCollection: [\r\n                4,3,2,1\r\n            ]\r\n        },\r\n    ];\r\n\r\n    UnorderedCollections.process(['*'], expected, actual);\r\n    t.notDeepEqual(expected, actual);\r\n});\r\n\r\ntest(`this passes because the user has specified both the unordered top-level and the unordered subCollection`, (t) => {\r\n    let expected = [\r\n        {\r\n            subCollection: [\r\n                1,2,3,4\r\n            ]\r\n        },\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                5,6,7,8\r\n            ]\r\n        }\r\n    ];\r\n\r\n    let actual = [\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                8,6,7,5\r\n            ]\r\n        },\r\n        {\r\n            subCollection: [\r\n                4,3,2,1\r\n            ]\r\n        },\r\n    ];\r\n    UnorderedCollections.process(['*', '*.subCollection'], expected, actual);\r\n    t.deepEqual(expected, actual);\r\n});\r\n\r\n\r\ntest(`an ordered top-level collection can contain un-ordered child collection`, (t) => {\r\n    let expected = [\r\n        {\r\n            subCollection: [\r\n                1,2,3,4\r\n            ]\r\n        },\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                5,6,7,8\r\n            ]\r\n        }\r\n    ];\r\n\r\n    let actual = [\r\n        {\r\n            subCollection: [\r\n                4,3,2,1\r\n            ]\r\n        },\r\n        {\r\n            \"key\": \"value\",\r\n            subCollection: [\r\n                8,6,7,5\r\n            ]\r\n        }\r\n    ];\r\n\r\n    UnorderedCollections.process(['*.subCollection'], expected, actual);\r\n    t.deepEqual(expected, actual);\r\n});\r\n\r\ntest(`it aborts when a sub-collection doesn't exist in a payload`, (t) => {\r\n  let expected = [\r\n    {\r\n      subCollection: [\r\n        1,2,3,4\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"b\",\r\n      subCollection: [\r\n        5,6,7,8\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"a\"\r\n    }\r\n  ];\r\n\r\n  let actual = [\r\n    {\r\n      \"key\": \"a\"\r\n    },\r\n    {\r\n      subCollection: [\r\n        4,3,2,1\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"b\",\r\n      subCollection: [\r\n        8,6,7,5\r\n      ]\r\n    }\r\n  ];\r\n\r\n  UnorderedCollections.process(['*', '*.subCollection'], expected, actual);\r\n  t.deepEqual(expected, actual);\r\n});\r\n\r\ntest(`it catches when 2 unorderedCollections are NOT equal at the top-level`, (t) => {\r\n  let expected = [\r\n    {\r\n      subCollection: [\r\n        1,2,3,4\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"value\",\r\n      subCollection: [\r\n        5,6,7,8\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"hello\"\r\n    }\r\n  ];\r\n\r\n  let actual = [\r\n    {\r\n      \"key\": \"world\"\r\n    },\r\n    {\r\n      subCollection: [\r\n        4,3,2,1\r\n      ]\r\n    },\r\n    {\r\n      \"key\": \"value\",\r\n      subCollection: [\r\n        8,6,7,5\r\n      ]\r\n    }\r\n  ];\r\n\r\n  try {\r\n    UnorderedCollections.process(['*', '*.subCollection'], expected, actual);\r\n  } catch (e) {\r\n    t.is(e.message, `The collections at '*' are not equal OR the parent object is a member of an ambiguous collection`);\r\n  }\r\n});\r\n\r\ntest((t) => {\r\n    //  it throws an error when collections are ambiguous and there is know way to know if the order is correct\r\n    let expected = [\r\n        {\r\n            subCollection: [\r\n                1,2,3,4\r\n            ]\r\n        },\r\n        {\r\n            subCollection: [\r\n                5,6,7,8\r\n            ]\r\n        }\r\n    ];\r\n\r\n    let actual = [\r\n        {\r\n            subCollection: [\r\n                8,6,7,5\r\n            ]\r\n        },\r\n        {\r\n            subCollection: [\r\n                4,3,2,1\r\n            ]\r\n        }\r\n    ];\r\n\r\n    try {\r\n      UnorderedCollections.process(['*', '*.subCollection'], expected, actual);\r\n    } catch (e) {\r\n      t.is(e.message, `The collections at 'subCollection' are not equal OR the parent object is a member of an ambiguous collection`);\r\n    }\r\n});\r\n"]}